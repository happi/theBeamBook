[[CH-Processes]]
== Processes

The concept of lightweight processes is the essence of Erlang and the
BEAM; they are what makes BEAM stand out from other virtual machines.
In order to understand how the BEAM (and Erlang and Elixir) works you
need to know the details of how processes work, which will help you
understand the central concept of the BEAM, including what is easy and
cheap for a process and what is hard and expensive.

Almost everything in the BEAM is connected to the concept
of processes and in this chapter we will learn more about these
connections. We will expand on what we learned in the introduction and
take a deeper look at concepts such as memory management, message
passing, and in particular scheduling.

An Erlang process is very similar to an OS process. It has its own
address space, it can communicate with other processes through signals
and messages, and the execution is controlled by a preemptive
scheduler.

When you have a performance problem in an Erlang or Elixir system the
problem is very often stemming from a problem within a particular
process or from an imbalance between processes. There are of course
other common problems such as bad algorithms or memory problems which
we will look at in other chapters. Still, being able to pinpoint the
process which is causing the problem is always important, therefore we
will look at the tools available in the Erlang Runtime System for
process inspection.

We will introduce the tools throughout the chapter as we go through
how a process and the scheduler works, and then we will bring all
tools together for an exercise at the end.


=== What is a Process?

A ((process)) is an isolated entity where code execution occurs.
A process protects your system from errors in your code by
isolating the effect of the error to the process executing
the faulty code.

The runtime comes with a number of tools for inspecting processes to
help us find bottlenecks, problems and overuse of resources. These
tools will help you identify and inspect problematic processes.


==== Listing Processes from the Shell

Let us dive right in and look at which processes we have
in a running system. The easiest way to do that is to
just start an Erlang shell and issue the shell command ((`i()`)).
In Elixir you can call the function in the `shell_default` module as
`:shell_default.i`.

[source,bash]
----
$ erl
Erlang/OTP 19 [erts-8.1] [source] [64-bit] [smp:4:4] [async-threads:10]
               [kernel-poll:false]

Eshell V8.1  (abort with ^G)
1> i().
Pid                   Initial Call                     Heap     Reds Msgs
Registered            Current Function                 Stack              
<0.0.0>               otp_ring0:start/2                 376      579    0
init                  init:loop/1                         2              
<0.1.0>               erts_code_purger:start/0          233        4    0
erts_code_purger      erts_code_purger:loop/0             3              
<0.4.0>               erlang:apply/2                    987   100084    0
erl_prim_loader       erl_prim_loader:loop/3              5              
<0.30.0>              gen_event:init_it/6               610      226    0
error_logger          gen_event:fetch_msg/5               8              
<0.31.0>              erlang:apply/2                   1598      416    0
application_controlle gen_server:loop/6                   7              
<0.33.0>              application_master:init/4         233       64    0
                      application_master:main_loop/2      6              
<0.34.0>              application_master:start_it/4     233       59    0
                      application_master:loop_it/4        5              
<0.35.0>              supervisor:kernel/1               610     1767    0
kernel_sup            gen_server:loop/6                   9              
<0.36.0>              erlang:apply/2                   6772    73914    0
code_server           code_server:loop/1                  3              
<0.38.0>              rpc:init/1                        233       21    0
rex                   gen_server:loop/6                   9              
<0.39.0>              global:init/1                     233       44    0
global_name_server    gen_server:loop/6                   9              
<0.40.0>              erlang:apply/2                    233       21    0
                      global:loop_the_locker/1            5              
<0.41.0>              erlang:apply/2                    233        3    0
                      global:loop_the_registrar/0         2              
<0.42.0>              inet_db:init/1                    233      209    0
inet_db               gen_server:loop/6                   9              
<0.44.0>              global_group:init/1               233       55    0
global_group          gen_server:loop/6                   9              
<0.45.0>              file_server:init/1                233       79    0
file_server_2         gen_server:loop/6                   9              
<0.46.0>              supervisor_bridge:standard_error/ 233       34    0
standard_error_sup    gen_server:loop/6                   9              
<0.47.0>              erlang:apply/2                    233       10    0
standard_error        standard_error:server_loop/1        2              
<0.48.0>              supervisor_bridge:user_sup/1      233       54    0
                      gen_server:loop/6                   9              
<0.49.0>              user_drv:server/2                 987     1975    0
user_drv              user_drv:server_loop/6              9              
<0.50.0>              group:server/3                    233       40    0
user                  group:server_loop/3                 4              
<0.51.0>              group:server/3                    987    12508    0
                      group:server_loop/3                 4              
<0.52.0>              erlang:apply/2                   4185     9537    0
                      shell:shell_rep/4                  17              
<0.53.0>              kernel_config:init/1              233      255    0
                      gen_server:loop/6                   9              
<0.54.0>              supervisor:kernel/1               233       56    0
kernel_safe_sup       gen_server:loop/6                   9              
<0.58.0>              erlang:apply/2                   2586    18849    0
                      c:pinfo/1                          50              
Total                                                 23426   220863    0
                                                        222              
ok

----

The `i/0` function prints out a list of all processes in the system.
Each process gets two lines of information. The first two lines
of the printout are the headers telling you what the information
means. As you can see you get the Process ID (Pid) and the name of the
process if any, as well as information about the code where the process
was started and where it is currently executing. You also get information about the
heap and stack size and the number of reductions and messages in
the process. In the rest of this chapter we will learn in detail
what a stack, a heap, a reduction and a message are. For now we
can just assume that if there is a large number for the heap size,
then the process uses a lot of memory and if there is a large number
for the reductions then the process has executed a lot of code.

We can further examine a process with the `i/3` function. Let
us take a look at the `code_server` process. We can see in the
previous list that the process identifier (pid) of the `code_server`
is `<0.36.0>`. By calling `i/3` with the three numbers of
the pid we get this information:

[source,erlang]
----
2> i(0,36,0).
[{registered_name,code_server},
 {current_function,{code_server,loop,1}},
 {initial_call,{erlang,apply,2}},
 {status,waiting},
 {message_queue_len,0},
 {messages,[]},
 {links,[<0.35.0>]},
 {dictionary,[]},
 {trap_exit,true},
 {error_handler,error_handler},
 {priority,normal},
 {group_leader,<0.33.0>},
 {total_heap_size,46422},
 {heap_size,46422},
 {stack_size,3},
 {reductions,93418},
 {garbage_collection,[{max_heap_size,#{error_logger => true,
                                       kill => true,
                                       size => 0}},
                      {min_bin_vheap_size,46422},
                      {min_heap_size,233},
                      {fullsweep_after,65535},
                      {minor_gcs,0}]},
 {suspending,[]}]
3>
----

We got a lot of information from this call and in the rest of this
chapter we will learn in detail what most of these items mean. The
first line tells us that the process has been given a name
`code_server`. Next we can see in which function the process is
currently executing or suspended (`current_function`)
and the name of the function in which the process started executing
(`initial_call`).

We can also see that the process is suspended waiting for messages
(`{status,waiting}`) and that there are no messages in the
mailbox  (`{message_queue_len,0}`, `{messages,[]}`). We will look
closer at how message passing works later in this chapter.

The fields `priority`, `suspending`, `reductions`, `links`,
`trap_exit`, `error_handler`, and `group_leader` control the process
execution, error handling, and IO. We will look into this a bit more
when we introduce the _Observer_.

The last few fields (`dictionary`, `total_heap_size`, `heap_size`,
`stack_size`, and `garbage_collection`) give us information about the
process memory usage. We will look at the process memory areas in
detail in chapter xref:CH-Memory[].

Another, even more intrusive way of getting information
about processes is to use the process information given
by the ((`BREAK` menu)): `Ctrl+c p [enter]`. Note that while
you are in the `BREAK` state the whole node freezes.

==== Programmatic Process Probing

The shell functions just print the information about the
process but you can actually get this information as data,
so you can write your own tools for inspecting processes.
You can get a list of all processes with ((`erlang:processes/0`)),
and information about a specific process with
`erlang:process_info/1`. We can also use the function
`whereis/1` to get a pid from a name:

[source,erlang]
----

1> Ps = erlang:processes().
[<0.0.0>,<0.1.0>,<0.4.0>,<0.30.0>,<0.31.0>,<0.33.0>,
 <0.34.0>,<0.35.0>,<0.36.0>,<0.38.0>,<0.39.0>,<0.40.0>,
 <0.41.0>,<0.42.0>,<0.44.0>,<0.45.0>,<0.46.0>,<0.47.0>,
 <0.48.0>,<0.49.0>,<0.50.0>,<0.51.0>,<0.52.0>,<0.53.0>,
 <0.54.0>,<0.60.0>]
2> CodeServerPid = whereis(code_server).
<0.36.0>
3> erlang:process_info(CodeServerPid).
[{registered_name,code_server},
 {current_function,{code_server,loop,1}},
 {initial_call,{erlang,apply,2}},
 {status,waiting},
 {message_queue_len,0},
 {messages,[]},
 {links,[<0.35.0>]},
 {dictionary,[]},
 {trap_exit,true},
 {error_handler,error_handler},
 {priority,normal},
 {group_leader,<0.33.0>},
 {total_heap_size,24503},
 {heap_size,6772},
 {stack_size,3},
 {reductions,74260},
 {garbage_collection,[{max_heap_size,#{error_logger => true,
                                       kill => true,
                                       size => 0}},
                      {min_bin_vheap_size,46422},
                      {min_heap_size,233},
                      {fullsweep_after,65535},
                      {minor_gcs,33}]},
 {suspending,[]}]
----

By getting process information as data we can write code
to analyze or sort the data as we please. If we grab all
processes in the system (with `erlang:processes/0`) and
then get information about the heap size of each process
(with `erlang:process_info(P, total_heap_size)`) we can
then construct a list with pid and heap size and sort
it on heap size:

[source,erlang]
----
1> lists:reverse(lists:keysort(2,[{P,element(2,
    erlang:process_info(P,total_heap_size))}
    || P <- erlang:processes()])).
[{<0.36.0>,24503},
 {<0.52.0>,21916},
 {<0.4.0>,12556},
 {<0.58.0>,4184},
 {<0.51.0>,4184},
 {<0.31.0>,3196},
 {<0.49.0>,2586},
 {<0.35.0>,1597},
 {<0.30.0>,986},
 {<0.0.0>,752},
 {<0.33.0>,609},
 {<0.54.0>,233},
 {<0.53.0>,233},
 {<0.50.0>,233},
 {<0.48.0>,233},
 {<0.47.0>,233},
 {<0.46.0>,233},
 {<0.45.0>,233},
 {<0.44.0>,233},
 {<0.42.0>,233},
 {<0.41.0>,233},
 {<0.40.0>,233},
 {<0.39.0>,233},
 {<0.38.0>,233},
 {<0.34.0>,233},
 {<0.1.0>,233}]
2>
----

You might notice that many processes have a ((heap size)) of
233 words, that is because it is the default starting heap size
of a process.

See the documentation of the module `erlang` for a full description of
the information available from ((`process_info/2`)):
link:https://erlang.org/doc/apps/erts/erlang.html#process_info/2[]
Notice how the `process_info/1` function only returns a subset of all
the information available for the process and how the `process_info/2`
function can be used to fetch extra information. As an example, to
extract the ((`backtrace`)) for the `code_server` process above, we could
run:

[source,erlang]
----
3> process_info(whereis(code_server), backtrace).
{backtrace,<<"Program counter: 0x00000000161de900 (code_server:loop/1 + 152)\nCP: 0x0000000000000000 (invalid)\narity = 0\n\n0"...>>}
----

See the three dots at the end of the binary above? That means that the
output has been truncated. A useful trick to see the whole value is to
wrap the above function call using the ((`rp/1`)) function:

[source,erlang]
----
4> rp(process_info(whereis(code_server), backtrace)).
----

An alternative is to use the `io:put_chars/1` function, as follows:

[source,erlang]
----
5> {backtrace, Backtrace} = process_info(whereis(code_server), backtrace).
{backtrace,<<"Program counter: 0x00000000161de900 (code_server:loop/1 + 152)\nCP: 0x0000000000000000 (invalid)\narity = 0\n\n0"...>>}
6> io:put_chars(Backtrace).
----

Due to its verbosity, the output for commands `4>` and `6>` has not
been included here, but feel free to try the above commands in your
Erlang shell.

==== Using Observer to Inspect Processes

A third way of examining processes is with the
http://erlang.org/doc/apps/observer/observer_ug.html[_Observer_].
((Observer)) is an extensive graphical interface for inspecting
the Erlang Runtime System. We will use the Observer throughout
this book to examine different aspects of the system.

NOTE: To start Observer, Erlang needs to have been compiled with ((WxWidgets))
support, and the `observer` and `wx` applications must be available on the
node. You probably do not want that on your production system, but Observer
is made with this in mind. You can start Observer from an Erlang that has
been built with support for it, and then go into the "`Nodes`" menu and
select "`Connect node`" and you will be able to Observe the connected node
instead of the local node.

For now, we will just start Observer from the Erlang shell like this:

[source,erlang]
----
7> observer:start().
----

or from the Elixir shell with `:observer.start`. For debugging a live
system, you probably want to launch a temporary Erlang node just for
running Observer, using the ((`-hidden`)) flag to prevent the inspected nodes
from seeing the observer node:

[source,shell]
----
$ erl -hidden -sname observer -run observer
----

When Observer is started it will show you a system overview,
see the following screen shot:

image::../images/observer_system.png[Observer system information window showing system statistics including memory usage, atom count, process count, and scheduler information]

We will go over some of this information in detail later in
this and the next chapter. For now we will just use Observer to look
at the running processes. First we take a look at the
`Applications` tab which shows the ((supervision
tree)) of the running system:

image::../images/observer_applications.png[Observer applications tab showing running applications in a tree structure with supervision hierarchy]

Here we get a graphical view of how the processes are linked. This is
a very nice way to get an overview of how a system is structured.
You also get a nice feeling of processes as isolated entities
floating in space connected to each other through links.

To actually get some useful information about the processes
we switch to the `Processes` tab:

image::../images/observer_processes.png[Observer processes tab displaying a table of running processes with columns for PID, name, memory usage, message queue length, and reductions]

In this view we get basically the same information as with
`i/0` in the shell. We see the pid, the registered name,
number of reductions, memory usage and number of messages
and the current function.

We can also look into a process by double clicking on its
row, for example on the code server, to get the kind of
information you can get with `process_info/2`:

image::../images/observer_code_server.png[Observer process information window showing detailed statistics for the code_server process including state, memory usage, message queue, and stack trace]

We will not go through what all this information means
right now, but if you keep on reading all will eventually
be revealed.

.Enabling Observer
****
If you are building your application with ((Rebar3))
and you want to include the Observer application
in your build, you may need to add the applications
`observer` and `wx` to the list of applications in
the `relx` section of `rebar.config`.
****

Now that we have a basic understanding of what a process is
and some tools to find and inspect processes in a system, we
are ready to dive deeper to learn how a process is implemented.

=== Processes Are Just Memory

A process is basically four blocks of memory: a _stack_, a _heap_,
a _message area_, and the _Process Control Block_ (_the PCB_).


The ((stack)) is used for keeping track of program execution by storing
return addresses, for passing arguments to functions, and for keeping
local variables. Larger structures, such as lists and tuples are
stored on the ((heap)).

The _((message area))_, also called _the ((mailbox))_, is used
to store messages sent to the process from other processes.
The ((process control block)) is used to keep track of the state
of the process.

See xref:erlang_process_memory_1[] for an illustration of a process as memory.

[[erlang_process_memory_1]]
.Erlang Process Memory : Basic
[ditaa]
----
  +----------------------------+
  |           Process          |
  |                            |
  |  +---------+  +---------+  |
  |  |   PCB   |  |  Stack  |  |
  |  +---------+  +---------+  |
  |                            |
  |  +---------+  +---------+  |
  |  | Mailbox |  |  Heap   |  |
  |  +---------+  +---------+  |
  |                            |
  +----------------------------+

----


This picture of a process is very much simplified, and we will go
through a number of iterations of more refined versions to get to a
more accurate picture.

The stack, the heap, and the mailbox are all dynamically allocated and
can grow and shrink as needed. We will see exactly how this works in
later chapters. The PCB on the other hand is statically allocated and
contains a number of fields that controls the process.

We can inspect some of these memory regions with built-in introspection calls.
For example, `erlang:process_info/2` lets you ask a process for its `stack_size`,
`heap_size`, `total_heap_size`, or a raw `backtrace` binary,
while the `current_stacktrace` item returns the stack as a structured
list of `{M,F,A,Location}` tuples that you can pattern-match or pretty-print yourself.
The shell helper `c:bt(Pid)` is just a convenience wrapper around `erlang:process_display(Pid, backtrace)`.
Combined with `process_info` items such as `memory` or `reductions`,
these queries give a view of a process’s stack, heap, and PCB-like fields.

For a deeper, byte-level view the runtime ships with the **Erlang Toolkit for Pathologist (EPT)**—a collection of GDB macros (`etp-stackdump`, `etp-heapdump`, `etp-process-info`, and friends) that walk live BEAM data structures in a paused VM or core dump. 

See xref:AP-BuildingERTS[] for more information on how to build the a debug version of the
Erlang runtime system with ETP support. 

We can see the context of the stack of a process with `erlang:process_display/2`:

[source,erlang]
----
1> erlang:process_display(self(), backtrace).
Program counter: 0x00007fdf9baa2e78 (erlang:self/0 + 32)

0x00007fdedf247480 Return addr 0x00007fdf9baa2118 (erlang:process_display/2 + 128)
y(0)     []
y(1)     backtrace
y(2)     <0.89.0>

0x00007fdedf2474a0 Return addr 0x00007fdf9bbb7644 (erl_eval:do_apply/7 + 308)
y(0)     none
y(1)     []

0x00007fdedf2474b8 Return addr 0x00007fdf9bf0e430 (shell:exprs/7 + 536)
y(0)     []
y(1)     []
y(2)     []
y(3)     []
y(4)     cmd
y(5)     []
y(6)     {value,#Fun<shell.5.46532814>}
y(7)     {eval,#Fun<shell.23.46532814>}
y(8)     #Ref<0.908573933.3456499713.143140>
y(9)     []

0x00007fdedf247510 Return addr 0x00007fdf9bf0dc60 (shell:eval_exprs/7 + 152)
y(0)     []
y(1)     []
y(2)     []
y(3)     []
y(4)     <0.88.0>
y(5)     Catch 0x00007fdf9bf0dd0e (shell:eval_exprs/7 + 326)

0x00007fdedf247548 Return addr 0x00007fdf9bf0d87c (shell:eval_loop/4 + 564)
y(0)     #Ref<0.908573933.3456499713.143140>
y(1)     #Ref<0.908573933.3456499713.143160>
y(2)     <0.88.0>

0x00007fdedf247568 Return addr 0x00007fdf9ba2d1f8 (<terminate process normally>)
true
----

We will look closer at the values on the stack and the
heap in xref:CH-TypeSystem[].


You can inspect the heap of a process with RTP and a debug version of
the BEAM. 

Assuming you have built a debug version:

[source,bash]
----
$ERL_TOP/bin/cerl -debug -rgdb
GNU gdb (Ubuntu 15.0.50.20240403-0ubuntu1) 15.0.50.20240403-git
...
Reading symbols from beam.debug.smp...
%---------------------------------------------------------------------------
% Use etp-help for a command overview and general help.
%
% To use the Erlang support module, the environment variable ROOTDIR
% must be set to the toplevel installation directory of Erlang/OTP,
% so the etp-commands file becomes:
%     $ROOTDIR/erts/etc/unix/etp-commands
% Also, erl and erlc must be in the path.
%---------------------------------------------------------------------------
etp-set-max-depth 20
etp-set-max-string-length 100
--------------- System Information ---------------
OTP release: 24
ERTS version: 12.3.2.17
Arch: x86_64-pc-linux-gnu
Endianness: Little
Word size: 64-bit
BeamAsm support: yes
--Type <RET> for more, q to quit, c to continue without paging--
SMP support: yes
Thread support: yes
Kernel poll: Supported
Debug compiled: yes
Lock checking: yes
Lock counting: no
System not initialized
--------------------------------------------------
----
Then you can start the BEAM with run.

[source,bash]
----

(gdb) run
Starting program: /home/happi/hh/theBeamBook/otp24/bin/x86_64-pc-linux-gnu/beam.debug.smp -- -root /home/happi/hh/theBeamBook/otp24 -progname /home/happi/hh/theBeamBook/otp24/bin/cerl -debug -- -home /home/happi -- -emu_type debug

This GDB supports auto-downloading debuginfo from the following URLs:
  <https://debuginfod.ubuntu.com>
Enable debuginfod for this session? (y or [n]) y
Debuginfod has been enabled.
To make this setting permanent, add 'set debuginfod enabled on' to .gdbinit.
warning: could not find '.gnu_debugaltlink' file for /lib/x86_64-linux-gnu/libtinfo.so.6
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
[New Thread 0x7fffb6baf6c0 (LWP 2185)]
...
[New Thread 0x7fff9f4fa6c0 (LWP 2232)]
Erlang/OTP 24 [erts-12.3.2.17] [source] [64-bit] [smp:16:16] [ds:16:16:10] [async-threads:1] [jit] [type-assertions] [debug-compiled] [lock-checking]

Eshell V12.3.2.17  (abort with ^G)
1>
----

Let us start a process with some dynamic data on the heap:

[source,erlang]
----
-module(mini_proc).
-export([wait/0]).

wait() ->
  X = {timestamp, erlang:timestamp()},
  receive _ -> X end,
  X.
----

Now we can compile and start that process in the shell within the debugger:

[source,erlang]
----
1> c(mini_proc).
{ok,mini_proc}
9> P3 = spawn(mini_proc, wait, []).
<0.101.0>
----

By pressing `Ctrl+c` we get back to the debugger:

----
    Thread 1 "beam.debug.smp" received signal SIGINT, Interrupt.
                                                                [Switching to Thread 0x7ffff79b3c40 (LWP 2170)]
(gdb)
----

I had some problem with the ETP commands unless I was in a scheduler thread, so let's switch to one
and list the processes:

----
(gdb) thread 7
[Switching to thread 7 (Thread 0x7fffb40b96c0 (LWP 2191))]
(gdb) etp-processes
---
  Pix: 0
  Pid: <0.0.0>
  State: prq-prio-normal | usr-prio-normal | act-prio-normal

  Flags: trap-exit
  Registered name: init
  Current function: unknown
  I: #Cp<init:loop/1+0x64>
  Heap size: 987
  Old-heap size: 987
  Mbuf size: 38
  Msgq len: 0 (inner=0, outer=0)
  Msgq Flags: on-heap
  Parent: []
  Pointer: (Process*)0x5555561301c8

...

---
  Pix: 808
  Pid: <0.101.0>
  State: prq-prio-normal | usr-prio-normal | act-prio-normal

  Flags:
  Current function: unknown
  I: #Cp<0x7fffb53711dc>
  Heap size: 233
  Old-heap size: 0
  Mbuf size: 0
  Msgq len: 0 (inner=0, outer=0)
  Msgq Flags: on-heap
  Parent: <0.93.0>
  Pointer: (Process*)0x7fff9ed6e030
---
  Pix: 816
  Pid: <0.102.0>
  State: prq-prio-normal | usr-prio-normal | act-prio-normal

  Flags:
  Current function: unknown
  I: #Cp<io:execute_request/3+0x1a4>
  Heap size: 233
  Old-heap size: 0
  Mbuf size: 0
  Msgq len: 0 (inner=0, outer=0)
  Msgq Flags: on-heap
  Parent: <0.79.0>
  Pointer: (Process*)0x7fff9ed6dce8
---
(gdb) 
----

We see the address of the '<0.101.0>' process in the `Pointer` field.
We can use the `etp-stackdump` and `etp-heapdump` commands to
inspect the stack and heap of the process. The `etp-stackdump`
command takes a process pointer as an argument. 

----
(gdb) set $p = ((Process *) 0x7fff9ed6e030)
(gdb) etp-stackdump $p
% Stacktrace (3)
I: #Cp<0x7fffb53711dc>.
0: {timestamp,{1747,147859,212377}}.
1: #Cp<0x7fffb4c14a78>.
2: #Cp<0x7fffb4c14a78>.
(gdb) etp-heapdump $p
% heapdump (7):
 0x7fff9eaf8278: | H:   3-tuple | I:      1747 | I:    147859 | I:    212377 | H:   2-tuple |    timestamp | B:0x9eaf827a
(gdb)  
----

As expected the stack and the heap contains a 2-tuple with the 3-tuple timestamp: `{timestamp, {1747,147859,212377}}`.



=== The PCB

The ((Process Control Block)) contains all the fields that control the
behaviour and current state of a process. In this section and the rest
of the chapter we will go through the most important fields. We will
leave out some fields that have to do with execution and tracing from
this chapter, instead we will cover those in xref:CH-BEAM[].

We can see most of the fields in the PCB by just printing the value
of what the process pointer points to:

----
print *((Process *) 0x7fff9ed6e030)
$2 = {common =
      {id = 3470333576787,
       refc = {atmc = {counter = 1}, sint = 1},
       tracer = 59, trace_flags = 167772160,
       timer = {counter = 0},
       u = {alive = {started_interval = 263, reg = 0x0, links = 0x0,
                    lt_monitors = 0x0, monitors = 0x0}, 
                   release = {later = 263, func = 0x0, data = 0x0, next = 0x0}}},
      htop = 0x7fff9eaf82b0,
      stop = 0x7fff9eaf89a8,
      fcalls = 3998,
      freason = 0,
      fvalue = 59,
      heap = 0x7fff9eaf8278,
      hend = 0x7fff9eaf89c0,
      abandoned_heap = 0x0,
      heap_sz = 233,
      min_heap_size = 233,
      min_vheap_size = 46422,
      max_heap_size = 3,
      arity = 0,
      arg_reg = 0x7fff9ed6e0f8,
      max_arg_reg = 6,
      def_arg_reg = {588235, 322955, 59, 14178673876263027908, 14178673876263027908, 4000},
      i = 0x7fffb53711dc <mini_proc:wait/0+140>,
      catches = 0, rcount = 0, schedule_count = 0,
      reds = 6, flags = 0, group_leader = 2267742733347, ftrace = 59, next = 0x555556142888,
      uniq = 0,
      sig_qs = {first = 0x0, last = 0x7fff9ed6e170, save = 0x7fff9ed6e170, cont = 0x0,
                cont_last = 0x7fff9ed6e188,
                nmsigs = {next = 0x0, last = 0x0},
                recv_mrk_blk = 0x0, len = 0, flags = 2},
      bif_timers = 0x0, dictionary = 0x0,
      seq_trace_clock = 0, seq_trace_lastcnt = 0, seq_trace_token = 59,
      u = {real_proc = 0x8f9cb, terminate = 0x8f9cb,
           initial = {module = 588235, function = 322955, arity = 0}},
      current = 0x0, parent = 3195455669715, static_flags = 0,
      high_water = 0x7fff9eaf8278,
      old_hend = 0x0,
      old_htop = 0x0,
      old_heap = 0x0,
      gen_gcs = 0,
      max_gen_gcs = 65535,
      off_heap = {first = 0x0, overhead = 0},
      mbuf = 0x0, live_hf_end = 0xfffffffffffffff8, msg_frag = 0x0, mbuf_sz = 0,
      psd = {counter = 0},
      bin_vheap_sz = 46422, bin_old_vheap_sz = 46422, bin_old_vheap = 0,
      sys_task_qs = 0x0, dirty_sys_tasks = 0x0,
      state = {counter = 42}, dirty_state = {counter = 0},
      sig_inq = {first = 0x0, last = 0x7fff9ed6e2a8, len = 0,        
                 nmsigs = {next = 0x0, last = 0x0}},
      trace_msg_q = 0x0,lock = {flags = {counter = 0},
                                queue = {0x0, 0x0, 0x0, 0x0, 0x0},
                                locked = {{counter = 0}, {counter = 0}, {counter = 0},
                                          {counter = 0}, {counter = 0}}},
      scheduler_data = 0x0, run_queue = {counter = 140736249294720},
      last_htop = 0x7fff9eaf8298, last_mbuf = 0x0, heap_hfrag = 0x0, last_old_htop = 0x0,
      debug_reds_in = 4000
     }
----

If you want to dig even deeper than we will go in this chapter you can
look at the C source code. The ((PCB)) is implemented as a C struct called `process` in the file
https://github.com/erlang/otp/blob/OTP-19.3/erts/emulator/beam/erl_process.h[`erl_process.h`] for OTP19
or https://github.com/erlang/otp/blob/master/erts/emulator/beam/erl_process.h[`erl_process.h`]
for the latest version.

The field `id` contains the process ID (or PID).
'id = 3470333576787' which is '0b110010100000000000000000000000011001010011' in binary.
The process ID is an Erlang term and hence tagged (See xref:CH-TypeSystem[]). This means
that the 4 least significant bits are a tag (0011). In the
code section there is a module for inspecting Erlang terms
(see show.erl in the online appendix)
which we will cover in
the chapter on types. We can use it now to examine the
type of a tagged word though.

[source,erlang]
----
4> show:tag_to_type(3470333576787).
pid
5>
----

The fields ((`htop`)) and ((`stop`)) are pointers to the top of the ((heap)) and
the ((stack)), that is, they are pointing to the next free slots on the heap
or stack. The fields ((`heap`)) (start) and ((`hend`)) points to the start and
the stop of the whole heap, and ((`heap_sz`)) gives the size of the heap
in words. That is `hend - heap = heap_sz * 8` on a 64 bit machine and
`hend - heap = heap_sz * 4` on a 32 bit machine.

The field ((`min_heap_size`)) is the size, in words, that the heap starts
with and which it will not shrink smaller than, the default value is
233.

We can now refine the picture of the process heap with the
fields from the PCB that controls the shape of the heap,
see xref:erlang_process_heap[]:

[[erlang_process_heap]]
.Erlang Process Heap
[ditaa]
----
  hend ->  +----+    -
           |    |    ^
           |    |    |             -
  htop ->  |    |    | heap_sz*8   ^
           |....|    | hend-heap   | min_heap_size
           |....|    v             v
  heap ->  +----+    -             -
          The Heap

----

But wait, how come we have a heap start and a heap end, but no start
and stop for the stack? That is because the BEAM uses a trick to save
space and pointers by allocating the heap and the stack together. It
is time for our first revision of our process as memory picture. The
heap and the stack are actually just one memory area, as illustrated
in xref:erlang_process_memory_2[]:

[[erlang_process_memory_2]]
.Erlang Process Memory : Heap + Stack
[ditaa, separation=false]
----
  +----------------------------+
  |           Process          |
  |                            |
  |  +---------+  +---------+  |
  |  |   PCB   |  |  Stack  |  |
  |  +---------+  +---------+  |
  |               |  free   |  |
  |  +---------+  +---------+  |
  |  | Mailbox |  |  Heap   |  |
  |  +---------+  +---------+  |
  |                            |
  +----------------------------+

----

The stack grows towards lower memory addresses and the heap towards
higher memory, so we can also refine the picture of the heap
by adding the ((stack top)) pointer to the picture, see
xref:erlang_process_heap_and_stack[]:

[[erlang_process_heap_and_stack]]
.Erlang Process Heap and Stack
[ditaa]
----
  hend ->  +----+    -
           |....|    ^
  stop ->  |    |    |
           |    |    |
           |    |    |             -
  htop ->  |    |    | heap_sz     ^
           |....|    |             | min_heap_size
           |....|    v             v
  heap ->  +----+    -             -
          The Heap

----

If the pointers `htop` and `stop` should meet, the
process has run out of free memory and will have to call the garbage
collector to free up memory.

=== The Garbage Collector (GC)

The heap memory management schema is to use a per process copying
generational ((garbage collector)). When there is no more
space on the heap (or the stack, since they share the allocated memory
block), the garbage collector kicks in to free up memory.

The ((GC)) allocates a new memory area called the _to space_.
Then it goes through the stack to find all live _roots_ and
follows each root and copies the data on the heap to the new
heap. Finally it also copies the stack to the new heap and frees up
the old memory area.

The GC is controlled by these fields in the PCB:

[source,c]
----
    Eterm *high_water;
    Eterm *old_hend;     /* Heap pointers for generational GC. */
    Eterm *old_htop;
    Eterm *old_heap;
    Uint max_heap_size;  /* Maximum size of heap (in words). */
    Uint16 gen_gcs;      /* Number of (minor) generational GCs. */
    Uint16 max_gen_gcs;	 /* Max minor gen GCs before fullsweep. */

----

Since the garbage collector is generational it will use a heuristic to just look at
new data most of the time. That is, in what is called a _((minor
collection))_, the GC
only looks at the top part of the stack and moves new data to the new
heap. Old data, i.e., data allocated below the ((`high_water`)) mark
on the heap (see xref:erlang_process_memory_3[]), is moved to a special
area called the old heap.

Most of the time, then, there is
another heap area for
each process: the ((old heap)), handled by the fields `old_heap`,
`old_htop` and `old_hend` in the PCB. This almost brings us back to
our original picture of a process as four memory areas, as shown in
xref:erlang_process_memory_3[]:

[[erlang_process_memory_3]]
.Erlang Process Memory : GC
[ditaa, separation=false]
----
  +---------+                +-------+
  |  PCB    |                | Stack |  +-------+ <- old_hend
  +---------+                +-------+  +       +
                             | free  |  +-------+ <- old_htop
  +---------+  high_water -> +-------+  |  Old  |
  | Mailbox |                | Heap  |  | Heap  |
  +---------+                +-------+  +-------+ <- old_heap

----

When a process starts there is no old heap, but as soon as young data
has matured to old data and there is a garbage collection, the old
heap is allocated. The old heap is garbage collected when there
is a _((major collection))_, also called a _((full sweep))_.
See xref:CH-Memory[] for more
details of how garbage collection works. In that chapter we will
also look at how to track down and fix memory related problems.

=== Mailboxes and Message Passing

Process communication is done through message passing. A process
send is implemented so that a sending process copies the message
from its own heap to the mailbox of the receiving process.

In the early days of Erlang, concurrency was implemented solely by
Erlang's own scheduler performing the task switching. We will talk more about concurrency
in the section about the scheduler later in this chapter, for
now it is worth noting that in the first version of Erlang there
was no parallelism and there could only be one process
running at the time. In that version the sending process could
write data directly into the heap of the receiving process, without
locking.

==== Sending Messages in Parallel

When multicore systems were introduced and the Erlang implementation
was extended with more than one scheduler running processes in parallel it
was no longer safe to write directly into another process' heap without
taking the _main lock_ of the receiver. At this time the concept of
_m-bufs_ was introduced (also called _((heap fragments))_). An ((`m-buf`)) is
a memory area
outside of a process heap where other processes can
safely write data. If a sending process can not get the lock, it would
write to the `m-buf` instead. When all data of a message has been
copied to the `m-buf`, the message is linked to the process through the
mailbox. The linking (`LINK_MESSAGE` in
link:https://github.com/erlang/otp/blob/master/erts/emulator/beam/erl_message.h[erl_message.h])
appends the message to the receiver's
message queue.

The garbage collector would then copy the messages onto the process'
heap. To reduce the pressure on the GC the mailbox is divided into
two lists, one containing seen messages and one containing new messages.
The GC does not have to look at the new messages since we know they will
survive (they are still in the mailbox) and that way we can avoid some
copying.

=== Lock Free Message Passing

In Erlang 19 a new per process setting was introduced, ((`message_queue_data`)),
which can take the values `on_heap` or `off_heap`. When set to ((`on_heap`))
the sending process will first try to take the _((main lock))_ of the
receiver and if it succeeds the message will be copied directly
onto the receiver's heap. This can only be done if the receiver is
suspended and if no other process has grabbed the lock to send to
the same process. If the sender can not obtain the lock it will
allocate a heap fragment and copy the message there instead.

If the flag is set to ((`off_heap`)) the sender will not try to get the
lock and instead write directly to a heap fragment. This will reduce
lock contention but allocating a heap fragment is more expensive than
writing directly to the already allocated process heap and it can
lead to larger memory usage. There might be a large empty heap allocated
and still new messages are written to new fragments.

With `on_heap` allocation all the messages, both directly allocated on
the heap and messages in heap fragments, will be copied by the GC. If
the message queue is large and many messages are not handled and
therefore still are live, they will be promoted to the old heap and
the size of the process heap will increase, leading to higher
memory usage.

All messages are added to a linked list (the mailbox) when the
message has been copied to the receiving process. If the message
is copied to the heap of the receiving process the message is
linked in to the _internal message queue_ (or ((`seen`)) messages)
and examined by the GC.
In the `off_heap` allocation scheme new messages are placed in
the "`external`" _message in-queue_ and ignored by the GC.

==== Memory Areas for Messages

We can now revise our picture of the process as four memory areas
once more. Now the process is made up of five memory areas (two
mailboxes) and a varying number of heap fragments (`m-bufs`), as
shown in xref:erlang_process_memory_4[]:

[[erlang_process_memory_4]]
.Erlang Process Memory : Messages
[ditaa, separation=false]
----
 +-------+             +-------+
 |  PCB  |             | Stack |
 +-------+             +-------+
                       | free  |
 +-------+  +-------+  +-------+  +-------+
 | M-box |  | M-box |  | Heap  |  |  Old  |
 | intern|  | inq   |  |       |  | Heap  |
 +-------+  +-------+  +-------+  +-------+

 +-------+  +-------+  +-------+  +-------+
 | m−buf |  | m−buf |  | m−buf |  | m−buf |
 +-------+  +-------+  +-------+  +-------+

----

Each mailbox consists of a length and two pointers, stored in the fields
`msg.len`, `msg.first`, `msg.last` for the internal queue and `msg_inq.len`,
`msg_inq.first`, and `msg_inq.last` for the external in queue. There is
also a pointer to the next message to look at (`msg.save`) to implement
selective receive.

==== The Process of Sending a Message to a Process

We will ignore the distribution case for now, that is we will not
consider messages sent between Erlang nodes. Imagine two processes
`P1` and `P2`. Process `P1` wants to send a message (`Msg`) to process
`P2`, as illustrated by xref:erlang_message_passing_1[]:

[[erlang_message_passing_1]]
.Erlang Message Passing Step 1
[ditaa, separation=false]
----
                 P 1
 +---------------------------------+
 | +-------+  +-------+  +-------+ |
 | |  PCB  |  | Stack |  |  Old  | |
 | +-------+  +-------+  | Heap  | |
 |            | free  |  +-------+ |
 |            |       |            |
 | +-------+  +-------+  +-------+ |
 | | M-box |  | Heap  |  | M-box | |
 | | inq   |  | [Msg] |  | intern| |
 | +-------+  +-------+  +-------+ |
 +---------------------------------+

                  |
                  |  P2 ! Msg
                  v

                 P 2
 +---------------------------------+
 | +-------+  +-------+  +-------+ |
 | |  PCB  |  | Stack |  |  Old  | |
 | +-------+  +-------+  | Heap  | |
 |            | free  |  +-------+ |
 |            |       |            |
 | +-------+  +-------+  +-------+ |
 | | M-box |  | Heap  |  | M-box | |
 | | inq   |  |       |  | intern| |
 | +-------+  +-------+  +-------+ |
 +---------------------------------+

----

Process `P1` will then take the following steps:

* Calculate the size of `Msg`.
* Allocate space for the message (on or off `P2` 's heap as described before).
* Copy `Msg` from `P1` 's heap to the allocated space.
* Allocate and fill in an `ErlMessage` struct wrapping up the message.
* Link in the `ErlMessage` either in the `ErlMsgQueue` or in the `ErlMsgInQueue`.

If process `P2` is suspended and no other process is trying to
send a message to `P2` and there is space on the heap and the
allocation strategy is `on_heap` the message will directly end up
on the heap, as in xref:erlang_message_passing_2[]:

[[erlang_message_passing_2]]
.Erlang Message Passing Step 2
[ditaa, separation=false]
----
                 P 1
 +---------------------------------+
 | +-------+  +-------+  +-------+ |
 | |  PCB  |  | Stack |  |  Old  | |
 | +-------+  +-------+  | Heap  | |
 |            | free  |  +-------+ |
 |            |       |            |
 | +-------+  +-------+  +-------+ |
 | | M-box |  | Heap  |  | M-box | |
 | | inq   |  | [Msg] |  | intern| |
 | +-------+  +-------+  +-------+ |
 +---------------------------------+

                  |
                  |  P2 ! Msg
                  v

                 P 2
 +---------------------------------+
 | +-------+  +-------+  +-------+ |
 | |  PCB  |  | Stack |  |  Old  | |
 | +-------+  +-------+  | Heap  | |
 |            | free  |  +-------+ |
 |            |       |            |
 | +-------+  +-------+  +-------+ |
 | | M-box |  | Heap  |  | M-box | |
 | | inq   |  | [Msg] |  | intern| |
 | |       |  |       |  |       | |
 | |       |  |  ^    |  | first | |
 | +-------+  +--|----+  +---|---+ |
 |               |           v     |
 |               |       +-------+ |
 |               |       |next []| |
 |               |       | m  *  | |
 |               |       +----|--+ |
 |               |            |    |
 |               +------------+    |
 +---------------------------------+


----

If `P1` can not get the `main lock` of P2 or there is not enough space
on `P2` 's heap and the allocation strategy is `on_heap` the message
will end up in an `m-buf` but linked from the internal mailbox, as in
xref:erlang_message_passing_3[]:

[[erlang_message_passing_3]]
.Erlang Message Passing Step 3
[ditaa, separation=false]
----
                 P 1
 +---------------------------------+
 | +-------+  +-------+  +-------+ |
 | |  PCB  |  | Stack |  |  Old  | |
 | +-------+  +-------+  | Heap  | |
 |            | free  |  +-------+ |
 |            |       |            |
 | +-------+  +-------+  +-------+ |
 | | M-box |  | Heap  |  | M-box | |
 | | inq   |  | [Msg] |  | intern| |
 | +-------+  +-------+  +-------+ |
 +---------------------------------+

                  |
                  |  P2 ! Msg
                  v

                 P 2
 +---------------------------------+
 | +-------+  +-------+  +-------+ |
 | |  PCB  |  | Stack |  |  Old  | |
 | +-------+  +-------+  | Heap  | |
 |            | free  |  +-------+ |
 |            |       |            |
 | +-------+  +-------+  +-------+ |
 | | M-box |  | Heap  |  | M-box | |
 | | inq   |  |       |  | intern| |
 | |       |  |       |  |       | |
 | |       |  |       |  | first | |
 | +-------+  +-------+  +---|---+ |
 |              m−buf        v     |
 |            +-------+  +-------+ |
 |         +->| [Msg] |  |next []| |
 |         |  |       |  | m  *  | |
 |         |  +-------+  +----|--+ |
 |         |                  |    |
 |         +------------------+    |
 +---------------------------------+


----

After a GC the message will be moved into
the heap.

If the allocation strategy is `off_heap` the message
will end up in an `m-buf` and linked from the external mailbox,
as in xref:erlang_message_passing_4[]:

[[erlang_message_passing_4]]
.Erlang Message Passing Step 4
[ditaa, separation=false]
----
                 P 1
 +---------------------------------+
 | +-------+  +-------+  +-------+ |
 | |  PCB  |  | Stack |  |  Old  | |
 | +-------+  +-------+  | Heap  | |
 |            | free  |  +-------+ |
 |            |       |            |
 | +-------+  +-------+  +-------+ |
 | | M-box |  | Heap  |  | M-box | |
 | | inq   |  | [Msg] |  | intern| |
 | +-------+  +-------+  +-------+ |
 +---------------------------------+

                  |
                  |  P2 ! Msg
                  v

                 P 2
 +---------------------------------+
 | +-------+  +-------+  +-------+ |
 | |  PCB  |  | Stack |  |  Old  | |
 | +-------+  +-------+  | Heap  | |
 |            | free  |  +-------+ |
 |            |       |            |
 | +-------+  +-------+  +-------+ |
 | | M-box |  | Heap  |  | M-box | |
 | | inq   |  |       |  | intern| |
 | |       |  |       |  |       | |
 | | first |  |       |  | first | |
 | +---|---+  +-------+  +-------+ |
 |     v        m−buf              |
 | +--------+  +-----+             |
 | |next [] |  |     |             |
 | |        |  |     |             |
 | | m *------>|[Msg]|             |
 | |        |  |     |             |
 | +--------+  +-----+             |
 +---------------------------------+
----

After a GC the message will still be in the `m-buf`. Not until
the message is received and reachable from some other object on
the heap or from the stack will the message be copied to the process
heap during a GC.

==== Receiving a Message

Erlang supports selective receive, which means that a message that
doesn't match can be left in the mailbox for a later receive. And the
processes can be suspended with messages in the mailbox when no
message matches. The `msg.save` field contains a pointer to a pointer
to the next message to look at.

In later chapters we will cover the details of `m-bufs` and how the
garbage collector handles mailboxes. We will also go through the
details of how receive is implemented in the BEAM
in later chapters.

==== Tuning Message Passing

With the new ((`message_queue_data`)) flag introduced in Erlang 19 you
can trade memory for execution time in a new way. If the receiving
process is overloaded and holding on to the `main lock`, it might be
a good strategy to use the ((`off_heap`)) allocation in order to let the
sending process quickly dump the message in an `m-buf`.

If two processes have a nicely balanced producer consumer behavior
where there is no real contention for the process lock then allocation
directly on the receivers heap will be faster and use less memory.

If the receiver is backed up and is receiving more messages than it
has time to handle, it might actually start using more memory as
messages are copied to the heap, and migrated to the old heap. Since
unseen messages are considered live, the heap will need to grow and use
more memory.

In order to find out which allocation strategy is best for your system
you will need to benchmark and measure the behavior. The first and easiest
test to do is probably to change the default allocation strategy at
the start of the system. The ERTS flag ((`+hmqd`)) sets the default strategy to
either `off_heap` or `on_heap`.
If you start Erlang without this flag the default will be `on_heap`.
By setting up your benchmark so that Erlang is started with
`+hmqd off_heap` you can test whether the system behaves better or
worse if all processes use off heap allocation.
Then you might want to find bottle neck processes and test switching
allocation strategies for those processes only.

=== The Process Dictionary

There is actually one more memory area in a process where
Erlang terms can be stored, the _Process Dictionary_.

The _((Process Dictionary))_ (PD) is a process local key-value store. One
advantage with it is that all keys and values are kept on the heap of the
process, so the terms you store do not need to be copied anywhere as
with message passing or ((ETS tables)).

We can now update our view of a process with yet another
memory area, PD, the process dictionary, as seen in
xref:erlang_process_memory_5[]:

[[erlang_process_memory_5]]
.Erlang Process Memory : Process Dictionary
[ditaa, separation=false]
----
 +-------+             +-------+  +-------+
 |  PCB  |             | Stack |  |  PD   |
 +-------+             +-------+  +-------+
                       | free  |
 +-------+  +-------+  +-------+  +-------+
 | M-box |  | M-box |  | Heap  |  |  Old  |
 | intern|  | inq   |  |       |  | Heap  |
 +-------+  +-------+  +-------+  +-------+

 +-------+  +-------+  +-------+  +-------+
 | m−buf |  | m−buf |  | m−buf |  | m−buf |
 +-------+  +-------+  +-------+  +-------+
----

The process dictionary is a very straighforward ((hash table))
implementation. In fact the PD memory area is just the plain bucket array,
and each slot is either ((`NIL`)) (the empty list) if the bucket is empty,
or otherwise it's a tagged pointer to data on the heap -- a simple tuple
`{Key, Value}` if there is only one entry in the bucket, or a
`NIL`-terminated list `[{Key1, Value1}, ..., {KeyN, ValueN}]` if the bucket
has N entries. You can find the implementation in the file
link:https://github.com/erlang/otp/blob/OTP-19.3/erts/emulator/beam/erl_process_dict.c[erl_process_dict.c].

This way, there is no additional complexity for managing dynamically
growing and shrinking bucket lists, and no separate memory management for
these data structures apart from the bucket array -- it is all handled by
the normal creation and freeing of tuples and lists on the heap (which is
already as efficient as you'd like). It also means that the garbage
collector can easily traverse the hash table much like any Erlang data. (In
xref:CH-Memory[] we will see the details of how garbage collection works.)

On the downside, the terms in the PD are always live data which needs to be
moved around by the (copying) GC. Hence, storing large amounts of data in
the PD can be a worse choice than using a separate ETS table even if
entries must then be copied in and out -- depending on how much load there
is on the GC after the initial growth phase of the dictionary. If you know
you are going to build up a large PD, it can be a good idea to start the
process off with a large initial heap size, as in `spawn_opt(...,
[{min_heap_size, Size}])`, and then try to do any GC-heavy work in another
process.

Note that, as with any hash table, storing an element in the PD is not
completely free -- it will result in an extra tuple for the key/value entry
and an extra cons cell if the bucket was not empty, which might also cause
garbage collection to be triggered. It could also require resizing of the
bucket array. Updating an existing key in the dictionary causes the whole
list of that bucket to be reallocated to make sure we don't get pointers
from the old heap to the new heap; however, these lists should on average
be very short.

=== Dig In

In this chapter we have looked at how a process is implemented. In
particular we looked at how the memory of a process is organized, how
message passing works and the information in the PCB. We also looked
at a number of tools for inspecting processes introspection, such as
`erlang:process_info/2`, and the ETP debug macros.

Use the functions `erlang:processes/0` and `erlang:process_info/1,2`
to inspect the processes in the system. Here are
some functions to try:

[source,erlang]
----

1> Ps = erlang:processes().
[<0.0.0>,<0.3.0>,<0.6.0>,<0.7.0>,<0.9.0>,<0.10.0>,<0.11.0>,
 <0.12.0>,<0.13.0>,<0.14.0>,<0.15.0>,<0.16.0>,<0.17.0>,
 <0.19.0>,<0.20.0>,<0.21.0>,<0.22.0>,<0.23.0>,<0.24.0>,
 <0.25.0>,<0.26.0>,<0.27.0>,<0.28.0>,<0.29.0>,<0.33.0>]
2> P = self().
<0.33.0>
3> erlang:process_info(P).
[{current_function,{erl_eval,do_apply,6}},
 {initial_call,{erlang,apply,2}},
 {status,running},
 {message_queue_len,0},
 {messages,[]},
 {links,[<0.27.0>]},
 {dictionary,[]},
 {trap_exit,false},
 {error_handler,error_handler},
 {priority,normal},
 {group_leader,<0.26.0>},
 {total_heap_size,17730},
 {heap_size,6772},
 {stack_size,24},
 {reductions,25944},
 {garbage_collection,[{min_bin_vheap_size,46422},
                      {min_heap_size,233},
                      {fullsweep_after,65535},
                      {minor_gcs,1}]},
 {suspending,[]}]
 4>  lists:keysort(2,[{P,element(2,erlang:process_info(P,
     total_heap_size))} || P <- Ps]).
[{<0.10.0>,233},
 {<0.13.0>,233},
 {<0.14.0>,233},
 {<0.15.0>,233},
 {<0.16.0>,233},
 {<0.17.0>,233},
 {<0.19.0>,233},
 {<0.20.0>,233},
 {<0.21.0>,233},
 {<0.22.0>,233},
 {<0.23.0>,233},
 {<0.25.0>,233},
 {<0.28.0>,233},
 {<0.29.0>,233},
 {<0.6.0>,752},
 {<0.9.0>,752},
 {<0.11.0>,1363},
 {<0.7.0>,1597},
 {<0.0.0>,1974},
 {<0.24.0>,2585},
 {<0.26.0>,6771},
 {<0.12.0>,13544},
 {<0.33.0>,13544},
 {<0.3.0>,15143},
 {<0.27.0>,32875}]
9> 

----
