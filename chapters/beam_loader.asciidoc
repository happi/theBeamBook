[[CH-Beam_loader]]
== The BEAM Loader

// Translation to internal format.
//   Optimizations.
//   Rewrites
//   Peephole optimisztions
//   pack engine?
//
// ops.tab format/syntax
//  Catches
// Linking and Exports

=== Transforming from Generic to Specific instructions

The BEAM loader does not just take the external beam format and writes
it to memory. It also does a number of transformations on the code
and translates from the external (generic) format to the internal
(specific) format.

The code for the loader can be found in +beam_load.c+ (in
+erts/emulator/+) but most of the logic for the translations are in
the file +ops.tab+ (in the same directory).

The first step of the loader is to parse beam file, basically the same
work as we did in Erlang in xref:CH-beam_modules[] but written in C.

Then the rules in ops.tab are applied to instructions in the code
chunk to translate the generic instruction to one or more specific
instructions.

The translation table works through pattern matching. Each line in the
file defines a pattern of one or more generic instructions with
arguments and optionally an arrow followed by one or more instructions
to translate to.

The transformations in ops tab tries to handle patterns of
instructions generated by the compiler and peephole optimize them to
fewer specific instructions. The ops tab transformations tries to
generate jump tables for patterns of selects.

The file ops.tab is not parsed at runtime, instead a pattern matching
program is generated from ops.tab and stored in an array in a
generated C file. The perl script +beam_makeops+ (in
+erts/emulator/utils+) generates a target specific set of opcodes and
translation programs in the files +beam_opcodes.h+ and
+beam_opcodes.c+ (these files end up in the given target directory
e.g. +erts/emulator/x86_64-unknown-linux-gnu/opt/smp/+).

The same program (beam_makeops) also generates the Erlang code for the
compiler back end +beam_opcodes.erl+.
